#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from Crypto.Hash import keccak # pycryptodome 

# https://docs.soliditylang.org/en/latest/units-and-global-variables.html
"""
Do not rely on block.timestamp or blockhash as a source of randomness, unless you know what you are doing.

Both the timestamp and the block hash can be influenced by miners to some degree. Bad actors in the mining community can for example run a casino payout function on a chosen hash and just retry a different hash if they did not receive any money.

The current block timestamp must be strictly larger than the timestamp of the last block, but the only guarantee is that it will be somewhere between the timestamps of two consecutive blocks in the canonical chain.
"""

"""
now = block.timestamp = 1606017237 # https://www.epochconverter.com/
block.blockhash(block.number - 1) = 0xadc250abb243bf2196fb18cb9e00c642eeaf2d0eb4d87cea2a7fd258845e8966

https://docs.soliditylang.org/en/latest/types.html
uint = uint256

"""

def exploit():
    block_hash = 0xadc250abb243bf2196fb18cb9e00c642eeaf2d0eb4d87cea2a7fd258845e8966
    block_timestamp = 1606017237

    block_hash_bytes = block_hash.to_bytes(32, byteorder="big")
    block_timestamp_bytes = block_timestamp.to_bytes(32, byteorder="big")
    keccak256 = keccak.new(digest_bits=256)
    keccak256.update(block_hash_bytes)
    keccak256.update(block_timestamp_bytes)
    ans = int.from_bytes(keccak256.digest(), byteorder="big", signed=False)
    ans = ans % 256
    print(ans)

if __name__ == "__main__":
    exploit()